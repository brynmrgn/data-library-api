require "test_helper"

class LdaFormatterServiceTest < ActiveSupport::TestCase
  def setup
    @data = sample_research_briefing_data.merge(
      "dc-term:identifier" => "CBP-1234",
      "dc-term:description" => "A test description"
    )
    @item = ResearchBriefing.new(id: "344893", data: @data, resource_type: :research_briefing)
  end

  # --- Value wrapping ---

  test "wraps identifier with _value only (no _datatype for strings)" do
    result = LdaFormatterService.format_item(@item)
    assert_equal({ "_value" => "CBP-1234" }, result["identifier"])
  end

  test "title is a plain string (not wrapped)" do
    result = LdaFormatterService.format_item(@item)
    assert_equal "Apprenticeship statistics (England)", result["title"]
  end

  test "wraps date values with _datatype dateTime" do
    result = LdaFormatterService.format_item(@item)
    assert_equal "dateTime", result["date"]["_datatype"]
    assert_match(/2024-12-06/, result["date"]["_value"])
  end

  test "description is a plain string array" do
    result = LdaFormatterService.format_item(@item)
    assert_equal ["A test description"], result["description"]
  end

  # --- Identifiers ---

  test "uses _about with full URI" do
    result = LdaFormatterService.format_item(@item)
    assert_equal "http://data.parliament.uk/resources/344893", result["_about"]
  end

  test "does not include id or uri keys" do
    result = LdaFormatterService.format_item(@item)
    assert_nil result["id"]
    assert_nil result["uri"]
  end

  # --- Field naming ---

  test "uses identifier field name" do
    result = LdaFormatterService.format_item(@item)
    assert result.key?("identifier"), "Expected identifier key"
  end

  test "maps author to creator" do
    result = LdaFormatterService.format_item(@item)
    assert result.key?("creator"), "Expected creator key"
    refute result.key?("author"), "Should not have author key"
  end

  # --- Type field ---

  test "includes type as RDF class URI string" do
    result = LdaFormatterService.format_item(@item)
    assert_equal "http://data.parliament.uk/schema/parl#ResearchBriefing", result["type"]
  end

  # --- New simple fields ---

  test "abstract is wrapped with _value only" do
    result = LdaFormatterService.format_item(@item)
    assert_equal({ "_value" => "Statistics on apprenticeships in England" }, result["abstract"])
  end

  test "created is wrapped with dateTime datatype" do
    result = LdaFormatterService.format_item(@item)
    assert_equal "dateTime", result["created"]["_datatype"]
    assert_match(/2015-03-25/, result["created"]["_value"])
  end

  test "modified is wrapped with dateTime datatype" do
    result = LdaFormatterService.format_item(@item)
    assert_equal "dateTime", result["modified"]["_datatype"]
    assert_match(/2024-12-06/, result["modified"]["_value"])
  end

  test "published is wrapped with boolean datatype" do
    result = LdaFormatterService.format_item(@item)
    assert_equal({ "_value" => "true", "_datatype" => "boolean" }, result["published"])
  end

  test "status is a plain string" do
    result = LdaFormatterService.format_item(@item)
    assert_equal "published", result["status"]
  end

  test "disclaimer is a plain string" do
    result = LdaFormatterService.format_item(@item)
    assert_equal "&lt;p&gt;This information is provided to Members of Parliament.&lt;/p&gt;", result["disclaimer"]
  end

  test "internalLocation is extracted as plain URI string" do
    result = LdaFormatterService.format_item(@item)
    assert_equal "http://researchbriefingsintranet.parliament.uk/ResearchBriefing/Summary/SN06113", result["internalLocation"]
  end

  # isPrimaryTopicOf is generated by the controller (not from SPARQL data)

  # --- Nested term objects ---

  test "formats nested subjects with _about and prefLabel" do
    result = LdaFormatterService.format_item(@item)
    subjects = result["subject"]
    assert_instance_of Array, subjects, "Multiple subjects should be an array"

    first = subjects.first
    assert first.key?("_about"), "Nested object should have _about"
    assert first.key?("prefLabel"), "Term reference should have prefLabel"
    assert first["prefLabel"].key?("_value"), "prefLabel should be wrapped with _value"
    refute first["prefLabel"].key?("_datatype"), "prefLabel should not have _datatype"
  end

  test "formats single nested object as object not array" do
    result = LdaFormatterService.format_item(@item)
    creator = result["creator"]
    assert_instance_of Hash, creator, "Single nested object should be an object, not array"
    assert creator.key?("_about"), "Nested object should have _about"
  end

  # --- Nested sub-objects (author) ---

  test "formats author properties in camelCase" do
    result = LdaFormatterService.format_item(@item)
    creator = result["creator"]
    assert_equal({ "_value" => "Matthew" }, creator["givenName"])
    assert_equal({ "_value" => "Ward" }, creator["familyName"])
  end

  test "formats author ses_id as URI reference" do
    result = LdaFormatterService.format_item(@item)
    creator = result["creator"]
    assert_equal "http://data.parliament.uk/terms/395733", creator["sesId"]
  end

  test "creator has Person type" do
    result = LdaFormatterService.format_item(@item)
    creator = result["creator"]
    assert_equal "http://schema.org/Person", creator["type"]
  end

  # --- Nested related links ---

  test "formats multiple related links as array" do
    result = LdaFormatterService.format_item(@item)
    links = result["relatedLink"]
    assert_instance_of Array, links
    assert_equal 2, links.length
  end

  # --- format_items ---

  test "format_items maps over multiple items" do
    items = [
      ResearchBriefing.new(id: "1", data: @data, resource_type: :research_briefing),
      ResearchBriefing.new(id: "2", data: @data, resource_type: :research_briefing)
    ]
    results = LdaFormatterService.format_items(items)
    assert_equal 2, results.length
    assert results.all? { |r| r.key?("_about") }
  end

  # --- List envelope ---

  test "build_list_envelope has correct top-level structure" do
    envelope = LdaFormatterService.build_list_envelope(
      items: [],
      total: 100,
      page: 0,
      page_size: 10,
      request: mock_lda_request
    )
    assert_equal "linked-data-api", envelope["format"]
    assert_equal "0.2", envelope["version"]
    assert envelope.key?("result")
  end

  test "build_list_envelope includes pagination metadata" do
    envelope = LdaFormatterService.build_list_envelope(
      items: [],
      total: 100,
      page: 0,
      page_size: 10,
      request: mock_lda_request
    )
    result = envelope["result"]
    assert_equal 100, result["totalResults"]
    assert_equal 10, result["itemsPerPage"]
    assert_equal 0, result["page"]
    assert_equal 1, result["startIndex"]
  end

  test "build_list_envelope includes next link when not on last page" do
    envelope = LdaFormatterService.build_list_envelope(
      items: [],
      total: 100,
      page: 0,
      page_size: 10,
      request: mock_lda_request
    )
    assert envelope["result"].key?("next"), "Should have next link"
  end

  test "build_list_envelope omits next link on last page" do
    envelope = LdaFormatterService.build_list_envelope(
      items: [],
      total: 10,
      page: 0,
      page_size: 10,
      request: mock_lda_request
    )
    refute envelope["result"].key?("next"), "Should not have next link on last page"
  end

  test "build_list_envelope includes prev link when not on first page" do
    envelope = LdaFormatterService.build_list_envelope(
      items: [],
      total: 100,
      page: 2,
      page_size: 10,
      request: mock_lda_request
    )
    assert envelope["result"].key?("prev"), "Should have prev link"
  end

  test "build_list_envelope omits prev link on first page" do
    envelope = LdaFormatterService.build_list_envelope(
      items: [],
      total: 100,
      page: 0,
      page_size: 10,
      request: mock_lda_request
    )
    refute envelope["result"].key?("prev"), "Should not have prev link on first page"
  end

  test "build_list_envelope includes isPartOf and type" do
    envelope = LdaFormatterService.build_list_envelope(
      items: [],
      total: 100,
      page: 0,
      page_size: 10,
      request: mock_lda_request
    )
    result = envelope["result"]
    assert result.key?("isPartOf")
    assert_equal "http://purl.org/linked-data/api/vocab#Page", result["type"]
  end

  # --- Show envelope ---

  test "build_show_envelope wraps item in primaryTopic" do
    item_hash = { "_about" => "http://data.parliament.uk/resources/123" }
    envelope = LdaFormatterService.build_show_envelope(
      item: item_hash,
      request: mock_lda_show_request
    )
    assert_equal "linked-data-api", envelope["format"]
    assert_equal "0.2", envelope["version"]
    assert_equal item_hash, envelope["result"]["primaryTopic"]
  end

  # --- Pagination URLs ---

  test "build_list_envelope uses _page param in URLs" do
    envelope = LdaFormatterService.build_list_envelope(
      items: [],
      total: 100,
      page: 0,
      page_size: 10,
      request: mock_lda_request
    )
    assert_match(/_page=1/, envelope["result"]["next"])
    assert_match(/_page=0/, envelope["result"]["first"])
  end

  test "build_list_envelope pagination links only include _page" do
    envelope = LdaFormatterService.build_list_envelope(
      items: [],
      total: 100,
      page: 0,
      page_size: 10,
      request: mock_lda_request
    )
    refute_match(/_pageSize/, envelope["result"]["next"])
  end

  private

  def mock_lda_request
    OpenStruct.new(
      base_url: "http://localhost:3000",
      path: "/api/v0/research-briefings",
      original_url: "http://localhost:3000/api/v0/research-briefings"
    )
  end

  def mock_lda_show_request
    OpenStruct.new(
      base_url: "http://localhost:3000",
      path: "/api/v0/research-briefings/344893",
      original_url: "http://localhost:3000/api/v0/research-briefings/344893"
    )
  end
end
